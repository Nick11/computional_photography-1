
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>start3</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-10-29"><meta name="DC.source" content="start3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">task 1</a></li><li><a href="#3">task 2</a></li><li><a href="#4">task 3</a></li><li><a href="#5">task 4</a></li><li><a href="#6">task 5</a></li><li><a href="#7">task 6</a></li></ul></div><pre class="codeinput"><span class="comment">% Computational Photography Project 1</span>
<span class="comment">% Turned in by &lt;Michael Single&gt;</span>
<span class="comment">% Legi: 08-917-445</span>

close <span class="string">all</span>
clear <span class="string">all</span>
clc

<span class="comment">% the following variables and handles are globally available</span>

img = imread(<span class="string">'imgs/castle_grey.jpg'</span>);
img = im2double(img);

<span class="comment">% test for squared error below eps</span>
eps = 1E-12;

<span class="comment">% helper function: For normalizing</span>

<span class="comment">% log power spectrum log(1+|F|^2)</span>
logPowerSpec = @(Mat)log(1 + Mat.*conj(Mat));

shiftMat2Min = @(Mat) Mat - min(Mat(:));
scaleMatByMax = @(Mat) Mat ./ max(Mat(:));

<span class="comment">% map values of a given matrix to range [0,1]</span>
normalizeMat = @(Mat) scaleMatByMax(shiftMat2Min(Mat));

transformBack = @(Mat) ifft2(ifftshift(Mat));
clipImg = @(Mat) abs(Mat(1:size(img,1), 1:size(img, 2)));

<span class="comment">% for inverse filtering</span>
clipTransformBack = @(Mat) clipImg(transformBack(Mat));
</pre><h2>task 1<a name="2"></a></h2><pre class="codeinput"><span class="comment">% a) plot function f(x) = cos(?ox) with ?o = 2?k/N, x ? [0, 16]</span>
<span class="comment">% and the sampled version f (n) frequency k = 1, . . . , 16.</span>
<span class="comment">% note that ?o denotes the angular frequency.</span>
figure(<span class="string">'Position'</span>, [100, 100, 1024, 800], <span class="string">'name'</span>,<span class="string">'Plots of cos(2pi*k*x/N) Plots'</span>);
N = 16;
idx = 1;
<span class="keyword">for</span> k=1:16
    h = subplot(4,4,idx);
    fplot(@(x) cos((2*pi()*k/N)*x), [0, 16])
    hold <span class="string">on</span>
    stem(cos((2*pi()*k/N)*(1:16)),<span class="string">'fill'</span>,<span class="string">'-.'</span>);
    hold <span class="string">off</span>
    title(strcat(<span class="string">'k='</span>,num2str(idx)))
    idx = idx + 1;
<span class="keyword">end</span>

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% 2.b) Indicate the value of ?o and k at which f(x) hits the Nyquist frequency</span>
disp([<span class="string">'N = '</span>, num2str(N), <span class="string">' thus N+1 = '</span>, num2str(N+1), <span class="string">' samples are used.'</span>]);
disp([<span class="string">'Hence, the sample rate f_s is equal to '</span>, num2str(N), <span class="string">' samples per time unit.'</span>]);
disp([<span class="string">'Since the  Nyquist frequency f_n is equal to 0.5*f_s'</span>]);
disp([<span class="string">'It follows f_n = '</span>,num2str(N/2),<span class="string">' for N equal to '</span>,num2str(N)]);
disp([<span class="string">'Since k denotes a frequency we can set k = f_n = '</span>, num2str(N/2), <span class="string">'(i.e. hit k hits Nyquist frequency)'</span>]);
disp([<span class="string">'Then omega = 2*pi*k/N = 2*pi*(N/2)/N = pi'</span>]);
disp(char(10));
<span class="comment">% ===================================================== end of subtask</span>
</pre><pre class="codeoutput">N = 16 thus N+1 = 17 samples are used.
Hence, the sample rate f_s is equal to 16 samples per time unit.
Since the  Nyquist frequency f_n is equal to 0.5*f_s
It follows f_n = 8 for N equal to 16
Since k denotes a frequency we can set k = f_n = 8(i.e. hit k hits Nyquist frequency)
Then omega = 2*pi*k/N = 2*pi*(N/2)/N = pi


</pre><img vspace="5" hspace="5" src="start3_01.png" alt=""> <h2>task 2<a name="3"></a></h2><pre class="codeinput"><span class="comment">% f_n are the samples of the input function</span>
<span class="comment">% F_m are the Fourier coefficients</span>
<span class="comment">% Let n,m in {0...M?1}, then for a fixed M</span>
<span class="comment">% a) create an M ? M matrix for the DFT containing the entries of a DFT</span>

<span class="comment">% F_m = \sum_{n=0}^{M-1} f_n e^{ \frac{-i 2\pi m*n}{M} }</span>
<span class="comment">% this is equivalent to F_m = *f_n</span>

<span class="comment">% predefined</span>
M = 10;

W_loop = zeros(M,M);
<span class="keyword">for</span> m=0:M-1,
    <span class="keyword">for</span> n=0:M-1,
        W_loop(m+1,n+1) = exp((-1i*2*pi()*m*n)/M);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Note that this could be further simplified:</span>
<span class="comment">% According to Euler's Formular exp(i*phi) = cos(phi) + i sin(phi)</span>
<span class="comment">% for phi (-2*pi()*m*n)/M) in this case it follows:</span>
<span class="comment">% cos(phi) + i sin(phi) = cos(-2*pi()*m*n)/M) + i sin(-2*pi()*m*n)/M)</span>
<span class="comment">% = cos(2*pi()*m*n)/M) - i sin(2*pi()*m*n)/M) % since sine is odd, cos even</span>

<span class="comment">% task a) without for loops</span>
<span class="comment">% m,n coefficient matrix</span>

<span class="comment">% Indices set M as repeated row vector.</span>
IDX = repmat((0:M-1),M, 1);

<span class="comment">% m,n coefficient matrix</span>
Cmn = IDX.*IDX';

<span class="comment">% phi matrix as described above in Euler's Formula</span>
phi = 2*pi()*Cmn/M;

<span class="comment">% Note that we have used sin(-x) = -sin(x)</span>
<span class="comment">% This allows us to abstain from the '-' sign in phi's def.</span>
W = cos(phi)-1i*sin(phi);

<span class="comment">% sanity check is loop W equal to loopless W?</span>
deltaW = (W - W_loop);
<span class="keyword">if</span>(abs(sum(deltaW(:))) &lt; 1E-12)
    disp(<span class="string">'W is okay'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'Error: W does not correspond to its loop version!'</span>)
<span class="keyword">end</span>
disp(char(10))
<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% b) check det(U), U*U' = eye(M) = U'*U</span>
disp(<span class="string">'Let U := W/sqrt(M)'</span>)
U = (W / sqrt(M));

<span class="comment">% due to numerical precisson we have to check</span>
<span class="comment">% whether |U*U' - I| &lt; eps |U'*U - I| &lt; eps |det(U) - 1| &lt; eps</span>

<span class="comment">% condition |det(U)| = 1</span>
cond1 = (abs(det(U))-1)^2 &lt; eps;

<span class="comment">% conditions U*U = UU* = I.</span>
cond2 = (sum(sum(U*U'-eye(M))))^2 &lt; eps;
cond3 = (sum(sum(U'*U-eye(M))))^2 &lt; eps;

<span class="comment">% in matlab comparison yielding true corresponds to be equal 1.</span>
<span class="comment">% since we have three conditions to check, all are true if their sum is 3.</span>
<span class="keyword">if</span>( cond1 + cond2 + cond3 == 3 )
    disp(<span class="string">'|det(U)| = 1 and U*U = UU* = I holds true'</span>);
<span class="keyword">else</span>
    disp(<span class="string">'Error: At least one condition, |det(U)| = 1 and U*U = UU* = I, does not true'</span>);
<span class="keyword">end</span>
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% c)</span>
<span class="comment">% Plot elements in DFT matrix</span>
figure(<span class="string">'Position'</span>, [100, 100, 1024, 800], <span class="string">'name'</span>, <span class="string">'real and imag DFT coefficent W plots'</span>);

<span class="comment">% A the k-th row in M corresponds to coefficients</span>
<span class="comment">% necessary in order to calculate F_k: F_k = M(k,;)*f_n</span>
<span class="comment">% Plot rows in W, i.e. coefficients F_k wise.</span>
<span class="keyword">for</span> m=0:M-1
    subplot(M,2,2*(m+1)-1);
    plot(0:M-1, real(W(m+1,:)), <span class="string">'r'</span>, 0:M-1, imag(W(m+1,:)), <span class="string">'b'</span>);
    <span class="keyword">if</span>(m==0)
        title(<span class="string">'Rows in DFT matrix, real (red) and imaginary (blue) (i-th figure are coeff of Fi)'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Plotting varying (sin, cos)(kx) for varying freq. values k. in range [0,M-1]</span>
<span class="keyword">for</span> k=0:M-1
    subplot(M,2,2*(k+1));
    fplot(@(x)sin(k*x), [0,M-1], <span class="string">'r'</span>);
    hold <span class="string">on</span>;
    fplot(@(x)cos(k*x), [0,M-1], <span class="string">'b'</span>);
    <span class="keyword">if</span>(k==0)
        title(<span class="string">'sin (red) and cos (blue) for varying frequency values k (i-th figure is k=i)'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
disp(<span class="string">'My Observations:'</span>);
disp(<span class="string">'Elements in W are equal to e^(-i*2*pi*k/M) = cos(-2*pi*k/M) + i*sin(-2*pi*k/M) (Euler Fromula)'</span>);
disp(<span class="string">'real(e^(-i*2*pi*k/M)) = cos(2*pi*k) (cos is even function'</span>);
disp(<span class="string">'imag(e^(-i*2*pi*k/M)) = -sin(2*pi*k/M) (sin is odd function'</span>);
disp(<span class="string">'Until Index M/2 + 1 (assuming M is even) the follwoing holds true:'</span>);
disp(<span class="string">'See first M/2 + 1 rows in first column in subfigure plots'</span>);
disp(<span class="string">'Therefore plotting real(e^(-i*2*pi*k/M) gives us a cosine wave with period k'</span>);
disp(<span class="string">'and plotting imag(e^(-i*2*pi*k/M) gives us a sine wave with period k'</span>);
disp(<span class="string">'Index m=M/2 has imag = 0'</span>);
disp(<span class="string">'The periods descrease symmetrically like they increased from this index on.'</span>);
disp(<span class="string">'In addition, since the real part is a cos wave which is an even function'</span>);
disp(<span class="string">'the plot of the k-th index is the same as (M/2 - k + 1)-th index (assuming M is even)'</span>);
disp(<span class="string">'Similarly, the can reason for sine, but it is flipped since sine is an even function'</span>);
disp(<span class="string">'i.e. sine at k-th plot corresponds to same plot times -1 of (M/2 - k + 1)-th'</span>);
disp(<span class="string">'To make this observation clear'</span>);
disp(<span class="string">'Set M=10 in this task and we assume that the first figure is labeled by index 1'</span>);
disp(<span class="string">'Comparing 3rd figure in column 1 with the 9th figure in column 1, we see that '</span>);
disp(<span class="string">'their red curves are the same and that the blue curve of the 3rd one is -1 times the 9th one'</span>);
disp(<span class="string">'furthermore both have a period equal to 2'</span>);
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">%d)</span>
<span class="comment">% Take M samples at 2n?/M, n = 0,...,M ?1 of cos(kx) and store them in a vector x.</span>
x = (2*pi()*(0:M-1));
<span class="keyword">for</span> k=0:M-1,
    disp([<span class="string">'For k='</span>,num2str(k), <span class="string">':'</span>]);
    Fk = W*cos(x)';
    matlabFk = fft(cos(k * x))';

    <span class="comment">% W*f_m is equal to FFT{f_m}</span>
    <span class="comment">% squered error below eps</span>
    dftsAreTheSame = sum(Fk-matlabFk)^2 &lt; eps;
    <span class="keyword">if</span>(dftsAreTheSame == 1)
        disp(<span class="string">'W*f_k is the same as Matlab`s FFT{f_k}'</span>)
    <span class="keyword">else</span>
        display(<span class="string">'Eror: W*f_k NOT SAME as Matlab`s FFT{f_k}'</span>)
    <span class="keyword">end</span>

    shiftedFk = fftshift(Fk);
    shiftedMatlabFk = fftshift(matlabFk);

    shiftedDftsAreTheSame = (sum(shiftedFk-shiftedMatlabFk)^2 &lt; eps);
    <span class="keyword">if</span>(shiftedDftsAreTheSame == 1)
        disp(<span class="string">'shifted W*f_k is the same as Matlab`s shifted FFT{f_k}'</span>)
    <span class="keyword">else</span>
        display(<span class="string">'Eror: shifted W*f_k NOT SAME as shifted Matlab`s FFT{f_k}'</span>)
    <span class="keyword">end</span>
    disp(char(10));
<span class="keyword">end</span>

disp(<span class="string">'My Intuition:'</span>);
disp(<span class="string">'from Matlab`s help page about the fftshift function:'</span>);
disp(<span class="string">'1. shifts the zero-frequency component to center of spectrum'</span>);
disp(<span class="string">'I.e. For a vector v, fftshift(v) swaps the left and right halves of v'</span>);
disp(char(10));
disp(<span class="string">'Fact: The dft of a function is a Periodic Function'</span>);
disp(<span class="string">'In our case we the dft of the function is a vector v with M elements.'</span>);
disp(<span class="string">'Appending the 2nd half of this vector to the first half'</span>);
disp(<span class="string">'which correspond to swapping the left and right halves of v'</span>);
disp(<span class="string">'this gives us a center symmetric vector looking like this'</span>);
disp(<span class="string">'[4,3,2,1,2,3] where `1` is the centered zero frequency.'</span>);
disp(<span class="string">'Before shifting: [1,2,3,4,3,2] we had this periodic function (aft dft)'</span>);
disp(char(10));

<span class="comment">% In addition the following example</span>
<span class="comment">% a random column vector with 9 elements.</span>
<span class="comment">%{
</span><span class="comment">randV =
</span><span class="comment">    0.9857
</span><span class="comment">    0.1528
</span><span class="comment">    0.7248
</span><span class="comment">    0.9652
</span><span class="comment">    0.3301
</span><span class="comment">    0.5656
</span><span class="comment">    0.0009
</span><span class="comment">    0.8532
</span><span class="comment">    0.5268
</span><span class="comment">
</span><span class="comment">% its dft transformation
</span><span class="comment">fft(randV) =
</span><span class="comment">   5.1052 + 0.0000i
</span><span class="comment">   0.4556 + 0.3877i
</span><span class="comment">  -0.1761 - 1.0960i
</span><span class="comment">   0.3752 - 0.4166i
</span><span class="comment">   1.2283 + 1.0215i
</span><span class="comment">   1.2283 - 1.0215i
</span><span class="comment">   0.3752 + 0.4166i
</span><span class="comment">  -0.1761 + 1.0960i
</span><span class="comment">   0.4556 - 0.3877i
</span><span class="comment">
</span><span class="comment">% its shifted dft transformation:
</span><span class="comment"> fftshift(fft(randV)) =
</span><span class="comment">   1.2283 - 1.0215i
</span><span class="comment">   0.3752 + 0.4166i
</span><span class="comment">  -0.1761 + 1.0960i
</span><span class="comment">   0.4556 - 0.3877i
</span><span class="comment">   5.1052 + 0.0000i
</span><span class="comment">   0.4556 + 0.3877i
</span><span class="comment">  -0.1761 - 1.0960i
</span><span class="comment">   0.3752 - 0.4166i
</span><span class="comment">   1.2283 + 1.0215i
</span><span class="comment">%}
</span>
<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% e)</span>
disp(<span class="string">'For 1D Fourier tranformation when given M elements'</span>);
disp(<span class="string">'The DFT has an asymptotic complexity of O(M^2)'</span>);
disp(<span class="string">'The FTT has an asymptotic complexity of O(M*log(M)'</span>);
disp(<span class="string">'Speedup factor using the FFT algorithm instead computing DFT Matrix:'</span>);
disp(<span class="string">'O([M^2] / [M*log(M)]) which is in O(M/log(M))'</span>);
disp(<span class="string">'E.g. given an nxn image (monochromatic) =&gt; i.e. M = n^2 (serialized image'</span>);
disp(<span class="string">'using the DFT algorithm has a asym. complexity in O([n^4]'</span>);
disp(<span class="string">'using the FFT algorithm has a asym. complexity in O([n^2 log(n^2)]'</span>);
disp(<span class="string">'which is equal to O([2*(n^2) log(n)] = O([(n^2)*log(n)]'</span>);
disp(<span class="string">'Assuming for the derivation of the FFT algorithm was a regular Divide&amp;Conquer approach applied'</span>)
disp(<span class="string">'we referre to the logarithm to the basis of 2, when talking about log'</span>)
disp(<span class="string">'Therefore, if n=400, then'</span>);
disp(<span class="string">'using the DFT algorithm: about 2.5600e+10 Iterations'</span>);
disp(<span class="string">'using the FFT algorithm: about 1.3830e+06 Iterations'</span>);
disp(<span class="string">'This is for this case a speedup about 4 orders of magnitude (1.8510e+04)'</span>);
disp(char(10));

<span class="comment">% ===================================================== end of subtask</span>
</pre><pre class="codeoutput">W is okay


Let U := W/sqrt(M)
|det(U)| = 1 and U*U = UU* = I holds true


My Observations:
Elements in W are equal to e^(-i*2*pi*k/M) = cos(-2*pi*k/M) + i*sin(-2*pi*k/M) (Euler Fromula)
real(e^(-i*2*pi*k/M)) = cos(2*pi*k) (cos is even function
imag(e^(-i*2*pi*k/M)) = -sin(2*pi*k/M) (sin is odd function
Until Index M/2 + 1 (assuming M is even) the follwoing holds true:
See first M/2 + 1 rows in first column in subfigure plots
Therefore plotting real(e^(-i*2*pi*k/M) gives us a cosine wave with period k
and plotting imag(e^(-i*2*pi*k/M) gives us a sine wave with period k
Index m=M/2 has imag = 0
The periods descrease symmetrically like they increased from this index on.
In addition, since the real part is a cos wave which is an even function
the plot of the k-th index is the same as (M/2 - k + 1)-th index (assuming M is even)
Similarly, the can reason for sine, but it is flipped since sine is an even function
i.e. sine at k-th plot corresponds to same plot times -1 of (M/2 - k + 1)-th
To make this observation clear
Set M=10 in this task and we assume that the first figure is labeled by index 1
Comparing 3rd figure in column 1 with the 9th figure in column 1, we see that 
their red curves are the same and that the blue curve of the 3rd one is -1 times the 9th one
furthermore both have a period equal to 2


For k=0:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=1:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=2:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=3:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=4:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=5:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=6:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=7:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=8:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


For k=9:
W*f_k is the same as Matlab`s FFT{f_k}
shifted W*f_k is the same as Matlab`s shifted FFT{f_k}


My Intuition:
from Matlab`s help page about the fftshift function:
1. shifts the zero-frequency component to center of spectrum
I.e. For a vector v, fftshift(v) swaps the left and right halves of v


Fact: The dft of a function is a Periodic Function
In our case we the dft of the function is a vector v with M elements.
Appending the 2nd half of this vector to the first half
which correspond to swapping the left and right halves of v
this gives us a center symmetric vector looking like this
[4,3,2,1,2,3] where `1` is the centered zero frequency.
Before shifting: [1,2,3,4,3,2] we had this periodic function (aft dft)


For 1D Fourier tranformation when given M elements
The DFT has an asymptotic complexity of O(M^2)
The FTT has an asymptotic complexity of O(M*log(M)
Speedup factor using the FFT algorithm instead computing DFT Matrix:
O([M^2] / [M*log(M)]) which is in O(M/log(M))
E.g. given an nxn image (monochromatic) =&gt; i.e. M = n^2 (serialized image
using the DFT algorithm has a asym. complexity in O([n^4]
using the FFT algorithm has a asym. complexity in O([n^2 log(n^2)]
which is equal to O([2*(n^2) log(n)] = O([(n^2)*log(n)]
Assuming for the derivation of the FFT algorithm was a regular Divide&amp;Conquer approach applied
we referre to the logarithm to the basis of 2, when talking about log
Therefore, if n=400, then
using the DFT algorithm: about 2.5600e+10 Iterations
using the FFT algorithm: about 1.3830e+06 Iterations
This is for this case a speedup about 4 orders of magnitude (1.8510e+04)


</pre><img vspace="5" hspace="5" src="start3_02.png" alt=""> <h2>task 3<a name="4"></a></h2><pre class="codeinput"><span class="comment">% a) compute 2dim Fourier transform of a grayscale image</span>
img = imread(<span class="string">'imgs/castle_grey.jpg'</span>);
img = im2double(img);
imgDft2 = fft2(img);

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% b)</span>
oneChannel = img(:,:,1);
centerFreqSameAsPixelsum = (imgDft2(1,1)-sum(oneChannel(:)))^2 &lt; eps;
<span class="keyword">if</span>(centerFreqSameAsPixelsum == 1)
    disp(<span class="string">'Element (1,1) of the Fourier transform corresponds to the sum over all pixel values.'</span>);
<span class="keyword">else</span>
    disp(<span class="string">'Error: Pixel value sum not central frequency (1,1)'</span>)
<span class="keyword">end</span>
disp(char(10));

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% c) Verify Perseval's Theorem.</span>
M = size(img,1)*size(img,2);
persevalsTheoremHoldsTrue = sum(sum(sum(img.^2))<span class="keyword">...</span>
                                -(1/M)*sum(sum(imgDft2.*conj(imgDft2)))).^2 &lt; eps;
<span class="keyword">if</span>(sum(persevalsTheoremHoldsTrue) == 1)
    disp(<span class="string">'Perseval`s Theorem holds true'</span>);
<span class="keyword">else</span>
    disp(<span class="string">'Error: Perseval`s Theorem does NOT hold true'</span>)
<span class="keyword">end</span>
disp(char(10));

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% d) Center dft2 of image</span>
centeredDFT = fftshift(imgDft2);

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% e) Visualize power spectrum</span>

<span class="comment">% power spectrum S = |F|^2</span>
S = centeredDFT .* conj(centeredDFT);

<span class="comment">% logarithmic values in order to reduce the contrast</span>
spectrum = log(1+S);
<span class="comment">% normalize spectrum linearly into range [0,1]</span>
spectrum = (spectrum - min(spectrum(:)));
spectrum = spectrum ./ max(spectrum(:));
figure(<span class="string">'name'</span>, <span class="string">'Centered and Scaled Power Spectrum of Image'</span>);
imshow(spectrum);

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% f) Visualize phase angles</span>

dftPhase = angle(centeredDFT);
dftPhase = dftPhase - min(dftPhase(:));
dftPhase = dftPhase ./ max(dftPhase(:));
figure(<span class="string">'name'</span>, <span class="string">'Centered and Scaled phase angles of Image'</span>);
imshow(dftPhase);

<span class="comment">% ===================================================== end of subtask</span>
</pre><pre class="codeoutput">Element (1,1) of the Fourier transform corresponds to the sum over all pixel values.


Perseval`s Theorem holds true


</pre><img vspace="5" hspace="5" src="start3_03.png" alt=""> <img vspace="5" hspace="5" src="start3_04.png" alt=""> <h2>task 4<a name="5"></a></h2><pre class="codeinput"><span class="comment">% a)</span>

<span class="comment">% Since filtering in the Fourier domain corresponds to circular convolution</span>
<span class="comment">% need to zero-pad the image to avoid boundary artifacts</span>
<span class="comment">% zero-pad using twice the size of the image itself</span>
dims = size(img);

<span class="comment">% apply dft with zero padding</span>
imgDft2 = fft2(img, 2*dims(1), 2*dims(2));

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% b)</span>

<span class="comment">% basic dimensions:</span>
[height, width, ~] = size(imgDft2);
h = (height - 1)/2;
w = (width - 1)/2;
<span class="comment">% Normalized Distances</span>
[x,y] = meshgrid(-w:w,-h:h);
D = x.^2 + y.^2;
D = D-min(D(:));
D = D ./ max(D(:));

<span class="comment">% Construct Buttworth Highpass filter: highpass = 1 - lowpass</span>
<span class="comment">% assuming (normalization): Is a function of (D0, n).</span>
H_lowpass = @(D0,n) 1./((1+(D/D0)).^(2*n));
H_highpass = @(D0,n) 1 - H_lowpass(D0,n);

<span class="comment">% constr</span>

<span class="comment">% Define band pass filter: as a function of (W,D0,n)</span>
H_bandass = @(W,D0,n) 1-(1 ./ (1 + ((W.*D)./(D.^2 - D0^2)).^(2*n)));

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% c)</span>
ns = [2, 10]; <span class="comment">% n value used in the slides.</span>
D0s = [0.1, 0.2, 0.3];
Ws = [0.05, 0.1, 0.2];

<span class="comment">% Superfancy-modular filter-visualization loop</span>
figure(<span class="string">'Position'</span>, [100, 100, 1024, 800], <span class="string">'name'</span>,<span class="string">'Visualize log Power Spectrum of filters'</span>);

figIdx = 1;
<span class="keyword">for</span> nIdx=1:length(ns),
    <span class="keyword">for</span> D0Idx=1:length(D0s),

        D0 = D0s(D0Idx);
        n = ns(nIdx);

        <span class="comment">% current lowpass filter</span>
        fig_title = strcat(<span class="string">'LowP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n));
        normLow = normalizeMat(logPowerSpec(H_lowpass(D0, n)));
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normLow);
        xlabelHandler = get(g,<span class="string">'XLabel'</span>);
        set( xlabelHandler, <span class="string">'String'</span>, fig_title);
        set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
        figIdx = figIdx + 1;


        <span class="comment">% current highpass filter</span>
        fig_title = strcat(<span class="string">'HiP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n));
        normHigh = normalizeMat(logPowerSpec(H_highpass(D0, n)));
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normHigh);
        xlabelHandler = get(g,<span class="string">'XLabel'</span>);
        set( xlabelHandler, <span class="string">'String'</span>, fig_title);
        set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
        figIdx = figIdx + 1;

        <span class="comment">% only for bandpass filter</span>
        <span class="keyword">for</span> WIdx=1:length(Ws),
            W = Ws(WIdx);
            fig_title = strcat(<span class="string">'BandP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n), <span class="string">' W'</span>,num2str(W));
            normBand = normalizeMat(logPowerSpec(H_bandass(W,D0,n)));
            g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
            subimage(normBand);
            xlabelHandler = get(g,<span class="string">'XLabel'</span>);
            set( xlabelHandler, <span class="string">'String'</span>, fig_title);
            set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
            figIdx = figIdx + 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% some legend related information</span>
disp(<span class="string">'Note that in the previous figure all a row corresponds to a certain D0'</span>);
disp(<span class="string">'The 1st column is the lowpass filter spectrums'</span>);
disp(<span class="string">'The 2nd column is the highpass filter spectrum'</span>);
disp(<span class="string">'And the columns 3-5 are the bandpass filter spectrums for varying W'</span>);
disp(char(10));
disp(char(10));

disp(<span class="string">'My observations:'</span>)
disp(<span class="string">'The filters in the previous figure are normalized - range from [0,1]'</span>)
disp(<span class="string">'Therefore, the brighter the higher the weighting value and vice versa'</span>)
disp(<span class="string">'White corresponds to the weight 1, black to the weight 0'</span>);
disp(<span class="string">'Low Pass filter: weighting frequencies closer the center more than those further away'</span>);
disp(<span class="string">'Select the lower frequencies:'</span>)
disp(<span class="string">'Filters hight frequencies out (the detail). Thus we get Blurs image'</span>);
disp(char(10));
disp(<span class="string">'High Pass filter: weights frequencies further away from the center more than those closer to the center'</span>);
disp(<span class="string">'Filters low frequencies out.'</span>)
disp(<span class="string">'The closer this filter gets towards zero, the closer its filtered result is to the original input image'</span>);
disp(char(10));
disp(<span class="string">'the bandpass filter is a disk selecting a certain band spectrum'</span>)
disp(char(10));
disp(<span class="string">'D0 affects the size of the radius:'</span>);
disp(<span class="string">'The bigger D0 the bigger the radius gets and vice versa.'</span>);
disp(<span class="string">'W affects the width of the filter band:'</span>);
disp(<span class="string">'Increasing W increases the filter band width.'</span>);
disp(<span class="string">'Loosly speaking it affects the inner radius of the disk'</span>);
disp(<span class="string">'the bigger W gets, the smaller the inner radius gets'</span>);
disp(<span class="string">'N Determins the smoothness of the circle border:'</span>);
disp(<span class="string">'The higher n gets the sharper the transition'</span>);
disp(<span class="string">'I.e. low value of n =&gt; smooth'</span>);
disp(<span class="string">'I.e. very high value of n =&gt; sharp'</span>);


<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% d)</span>
imgDft2 = imgDft2(:,:,1);
imgDft2 = fftshift(imgDft2);

<span class="comment">% showing power spectrum of images.</span>
figure(<span class="string">'Position'</span>, [100, 100, 1024, 800], <span class="string">'name'</span>,<span class="string">'Spectrum of filtered DFT Img'</span>);
figIdx = 1;
<span class="keyword">for</span> nIdx=1:length(ns),
    <span class="keyword">for</span> D0Idx=1:length(D0s),

        D0 = D0s(D0Idx);
        n = ns(nIdx);

        <span class="comment">% current lowpass filter</span>
        fig_title = strcat(<span class="string">'LowP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n));
        normLow = normalizeMat(logPowerSpec(imgDft2 .* H_lowpass(D0, n)));



        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normLow);
        xlabelHandler = get(g,<span class="string">'XLabel'</span>);
        set( xlabelHandler, <span class="string">'String'</span>, fig_title);
        set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
        figIdx = figIdx + 1;


        <span class="comment">% current highpass filter</span>
        fig_title = strcat(<span class="string">'HiP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n));
        normHigh = normalizeMat(logPowerSpec(imgDft2.*H_highpass(D0, n)));
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normHigh);
        xlabelHandler = get(g,<span class="string">'XLabel'</span>);
        set( xlabelHandler, <span class="string">'String'</span>, fig_title);
        set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
        figIdx = figIdx + 1;

        <span class="comment">% only for bandpass filter</span>
        <span class="keyword">for</span> WIdx=1:length(Ws),
            W = Ws(WIdx);
            fig_title = strcat(<span class="string">'BandP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n), <span class="string">' W'</span>,num2str(W));
            normBand = normalizeMat(logPowerSpec(imgDft2.*H_bandass(W,D0,n)));
            g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
            subimage(normBand);
            xlabelHandler = get(g,<span class="string">'XLabel'</span>);
            set( xlabelHandler, <span class="string">'String'</span>, fig_title);
            set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
            figIdx = figIdx + 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% recovering images using the filters</span>
figure(<span class="string">'Position'</span>, [100, 100, 1024, 800], <span class="string">'name'</span>,<span class="string">'Filter Imges'</span>);
figIdx = 1;
<span class="keyword">for</span> nIdx=1:length(ns),
    <span class="keyword">for</span> D0Idx=1:length(D0s),

        D0 = D0s(D0Idx);
        n = ns(nIdx);

        <span class="comment">% current lowpass filter</span>
        fig_title = strcat(<span class="string">'LowP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n));
        normLow = imgDft2 .* H_lowpass(D0, n);

        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(clipTransformBack(normLow));
        xlabelHandler = get(g,<span class="string">'XLabel'</span>);
        set( xlabelHandler, <span class="string">'String'</span>, fig_title);
        set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
        figIdx = figIdx + 1;


        <span class="comment">% current highpass filter</span>
        fig_title = strcat(<span class="string">'HiP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n));
        normHigh = imgDft2.*H_highpass(D0, n);
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(clipTransformBack(normHigh));
        xlabelHandler = get(g,<span class="string">'XLabel'</span>);
        set( xlabelHandler, <span class="string">'String'</span>, fig_title);
        set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
        figIdx = figIdx + 1;

        <span class="comment">% only for bandpass filter</span>
        <span class="keyword">for</span> WIdx=1:length(Ws),
            W = Ws(WIdx);
            fig_title = strcat(<span class="string">'BandP: D0='</span><span class="keyword">...</span>
                            ,num2str(D0), <span class="string">' n='</span>, num2str(n), <span class="string">' W'</span>,num2str(W));
            normBand = imgDft2.*H_bandass(W,D0,n);
            g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
            subimage(clipTransformBack(normBand));
            xlabelHandler = get(g,<span class="string">'XLabel'</span>);
            set( xlabelHandler, <span class="string">'String'</span>, fig_title);
            set(gca,<span class="string">'xtick'</span>,[],<span class="string">'ytick'</span>,[]);
            figIdx = figIdx + 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% ===================================================== end of subtask</span>
</pre><pre class="codeoutput">Note that in the previous figure all a row corresponds to a certain D0
The 1st column is the lowpass filter spectrums
The 2nd column is the highpass filter spectrum
And the columns 3-5 are the bandpass filter spectrums for varying W




My observations:
The filters in the previous figure are normalized - range from [0,1]
Therefore, the brighter the higher the weighting value and vice versa
White corresponds to the weight 1, black to the weight 0
Low Pass filter: weighting frequencies closer the center more than those further away
Select the lower frequencies:
Filters hight frequencies out (the detail). Thus we get Blurs image


High Pass filter: weights frequencies further away from the center more than those closer to the center
Filters low frequencies out.
The closer this filter gets towards zero, the closer its filtered result is to the original input image


the bandpass filter is a disk selecting a certain band spectrum


D0 affects the size of the radius:
The bigger D0 the bigger the radius gets and vice versa.
W affects the width of the filter band:
Increasing W increases the filter band width.
Loosly speaking it affects the inner radius of the disk
the bigger W gets, the smaller the inner radius gets
N Determins the smoothness of the circle border:
The higher n gets the sharper the transition
I.e. low value of n =&gt; smooth
I.e. very high value of n =&gt; sharp
</pre><img vspace="5" hspace="5" src="start3_05.png" alt=""> <img vspace="5" hspace="5" src="start3_06.png" alt=""> <img vspace="5" hspace="5" src="start3_07.png" alt=""> <h2>task 5<a name="6"></a></h2><pre class="codeinput"><span class="comment">% a)</span>
<span class="comment">% gaussian 5x5 kernel with sigma=3</span>
gaussianFilter = fspecial(<span class="string">'gaussian'</span>,5,1);
blurredImg = imfilter(img, gaussianFilter);

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% b)</span>

noisyBluredImg = imnoise(blurredImg, <span class="string">'gaussian'</span>, 0, 0.05);

<span class="comment">% c)</span>
<span class="comment">% centered zero-padded-dft of noisy and noisy-blured imgs</span>
dftBluredImg = fftshift(fft2(blurredImg, 2*dims(1), 2*dims(2)));
dftBluredImg = dftBluredImg(:,:,1);
dftNoisyBluredImg = fftshift(fft2(noisyBluredImg, 2*dims(1), 2*dims(2)));
dftNoisyBluredImg = dftNoisyBluredImg(:,:,1);
dftGaussian = fftshift(fft2(gaussianFilter, 2*dims(1), 2*dims(2)));

<span class="comment">% Inverse filtering</span>
invFilteredBlurred = dftBluredImg ./ dftGaussian;
invFilteredNoisyBlured = dftNoisyBluredImg ./ dftGaussian;

figure(<span class="string">'name'</span>, <span class="string">'Recovered blury image by Inverse Filtering'</span>)
imshow(clipTransformBack(invFilteredBlurred))

figure(<span class="string">'name'</span>, <span class="string">'Recovered Noisy image by Inverse Filtering'</span>)
imshow(clipTransformBack(invFilteredNoisyBlured))

figure(<span class="string">'name'</span>, <span class="string">'Recovered Noisy image by Inverse Filtering scaled linearly to [0,1] range'</span>)
imshow(normalizeMat(clipTransformBack(invFilteredNoisyBlured)))


disp(<span class="string">'Let I be a given image'</span>);
disp(<span class="string">'H denotes a filter (here a gaussian filter)'</span>);
disp(<span class="string">'and N denote noise'</span>);
disp(<span class="string">'Assuming the Degradation Model'</span>)
disp(<span class="string">'Then G = H*I + N is the noisy image'</span>)
disp(<span class="string">'Applying inverse filtering to G using H gives us then:'</span>)
disp(<span class="string">'invI = G/H = I + N/H'</span>);
disp(<span class="string">'If the elements in H are relatively small'</span>)
disp(<span class="string">'the ratio N/H will be relatively large'</span>)
disp(<span class="string">'Thus, assuming - which is the case in our example -'</span>)
disp(<span class="string">'that the values the elements in H (our gaussian Filter) are very small'</span>)
disp(<span class="string">'The noisy will then dominate in the recovered image invI'</span>)
disp(<span class="string">'This can be observed in the figures shown previousely.'</span>)
disp(<span class="string">'Note that scale the image linearly into the range [0,1] does not help'</span>)
disp(<span class="string">'This can also be oberved in one of the previous figures.'</span>)
disp(<span class="string">'In contrary, images without exhibiting any significant noise'</span>)
disp(<span class="string">'can be rather well recovered relying on the inverse method'</span>)
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% d)</span>

figure(<span class="string">'Position'</span>, [100, 100, 1440, 800], <span class="string">'name'</span>, <span class="string">'Recovered Noisy Image a using Wiener Filter'</span>);
SNR = 0:0.1:0.8;
<span class="keyword">for</span> idx = 1:length(SNR),
    recoveredImg = deconvwnr(noisyBluredImg, gaussianFilter, SNR(idx));
    subplot(3,3,idx);
    imshow(recoveredImg);
    title([<span class="string">'Recovered image using a Wiener Filter with SNR = '</span>, num2str(SNR(idx))]);
<span class="keyword">end</span>

disp(<span class="string">'The following reasoning does hold true for Wiener filters:'</span>);
disp(<span class="string">'SNR denotes signal to noise ratio, i.e. Sf(u;v) / Sn(u;v)'</span>);
disp(<span class="string">'IF the SNR is equal to zero then either'</span>);
disp(<span class="string">'a) Sf(u;v) is zero for all u,v i.e. there is no signal OR'</span>);
disp(<span class="string">'b) Sn(u;v) is extremly large for all u,v (almost infinity noise)'</span>);
disp(<span class="string">'Since case a) clearly cannot be true (since we do have a signal)'</span>);
disp(<span class="string">'i.e. an image != black'</span>);
disp(<span class="string">'Case be must be true'</span>);
disp(<span class="string">'Thus, case b) corresponds to the case when we have almost infinite noise (contribution)'</span>);
disp(<span class="string">'This can be observed in the first subfigure in the previous figure.'</span>);
disp(<span class="string">'Having almost inf. Noise will make the Wiener Filter formular almost equal zero'</span>);
disp(<span class="string">'and then only noise will then dominate.'</span>);
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>
</pre><pre class="codeoutput">Let I be a given image
H denotes a filter (here a gaussian filter)
and N denote noise
Assuming the Degradation Model
Then G = H*I + N is the noisy image
Applying inverse filtering to G using H gives us then:
invI = G/H = I + N/H
If the elements in H are relatively small
the ratio N/H will be relatively large
Thus, assuming - which is the case in our example -
that the values the elements in H (our gaussian Filter) are very small
The noisy will then dominate in the recovered image invI
This can be observed in the figures shown previousely.
Note that scale the image linearly into the range [0,1] does not help
This can also be oberved in one of the previous figures.
In contrary, images without exhibiting any significant noise
can be rather well recovered relying on the inverse method


The following reasoning does hold true for Wiener filters:
SNR denotes signal to noise ratio, i.e. Sf(u;v) / Sn(u;v)
IF the SNR is equal to zero then either
a) Sf(u;v) is zero for all u,v i.e. there is no signal OR
b) Sn(u;v) is extremly large for all u,v (almost infinity noise)
Since case a) clearly cannot be true (since we do have a signal)
i.e. an image != black
Case be must be true
Thus, case b) corresponds to the case when we have almost infinite noise (contribution)
This can be observed in the first subfigure in the previous figure.
Having almost inf. Noise will make the Wiener Filter formular almost equal zero
and then only noise will then dominate.


</pre><img vspace="5" hspace="5" src="start3_08.png" alt=""> <img vspace="5" hspace="5" src="start3_09.png" alt=""> <img vspace="5" hspace="5" src="start3_10.png" alt=""> <img vspace="5" hspace="5" src="start3_11.png" alt=""> <h2>task 6<a name="7"></a></h2><pre class="codeinput"><span class="comment">% a)</span>
disp(<span class="string">'Parseval`s Theorem states that squared sum of the coefficients of the spatial'</span>)
disp(<span class="string">'signal are equal to the squared sum of the signal in the frequency'</span>)
disp(<span class="string">'domain up to a factor N.'</span>);
disp(<span class="string">'I.e. the Energy of the spatial signal corresponds to '</span>)
disp(<span class="string">'the energy of the signal in the frequency scaled by a certain factor'</span>);
disp(<span class="string">'the factor M is the number of samples taken'</span>)
disp(<span class="string">'Since a image has n x n samples (assuming image has a quadratic resolution)'</span>)
disp(<span class="string">'A user specified value to the square root of 2 is proportinal the length and widht'</span>)
disp(<span class="string">'i.e. (imgLength - sqrt(1-percentage)*imgLength)) /2 '</span>)
disp(<span class="string">'This length determines the the window of zero elements in the DFT of the image'</span>)
disp(<span class="string">'A good strategy will be the following: Set high freqencies equal to zero'</span>)
disp(<span class="string">'related to the computed length above.'</span>);
disp(<span class="string">'Setting high-frequencies should work rather well since the human eye is more sensitive to low frequencies'</span>);
disp(<span class="string">'and is not able to distinguish exactly between strength levels of a high frequency brightness variation'</span>);
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% b)</span>

<span class="comment">% user specified percentage value</span>
p = 0.6;
q = 1-p;

heightR = round((dims(1) - sqrt(q)*dims(1))/2);
widthR = round((dims(2) - sqrt(q)*dims(2))/2);

<span class="comment">% dft is centered i.e. low freq. closer to center</span>
dftImg = fft2(img);
save(<span class="string">'imgs/uncompressed.mat'</span>, <span class="string">'dftImg'</span>);

<span class="comment">% show file size</span>
fileInfo = dir(<span class="string">'imgs/uncompressed.mat'</span>);
uncompressedMB = fileInfo.bytes/1024^2;
disp([<span class="string">'Size Uncompressed File: '</span>,num2str(uncompressedMB), <span class="string">' MB'</span>]);
disp(char(10))

dftImg = fftshift(dftImg);

figure(<span class="string">'Position'</span>, [100, 100, 1440, 800], <span class="string">'name'</span>, <span class="string">'Uncompressed Spectrum'</span>);
imshow(normalizeMat(logPowerSpec(dftImg)))

<span class="comment">% Replace high frequencies with 0</span>
<span class="comment">% zero-mask frequencies with a top-down-left-right-box having some</span>
<span class="comment">% width-height.</span>
<span class="comment">%{
</span><span class="comment">E.g.
</span><span class="comment">
</span><span class="comment">a a a a a a a a      0 0 0 0 0 0 0 0
</span><span class="comment">a a a a a a a a      0 0 0 0 0 0 0 0
</span><span class="comment">a a a a a a a a      0 0 a a a a 0 0
</span><span class="comment">a a a a a a a a  =&gt;  0 0 a a a a 0 0
</span><span class="comment">a a a a a a a a      0 0 a a a a 0 0
</span><span class="comment">a a a a a a a a      0 0 0 0 0 0 0 0
</span><span class="comment">a a a a a a a a      0 0 0 0 0 0 0 0
</span><span class="comment">
</span><span class="comment">%}
</span><span class="comment">% set all rows from row 1 to row heightR equal zero</span>
dftImg(1:heightR, :, :) = 0;

<span class="comment">% set all rows from row dims(1)-r_height to dims(1) equal zero</span>
dftImg(dims(1)-heightR:dims(1), :, :) = 0;

<span class="comment">% set all columns from column 1 to row heightR equal zero</span>
dftImg(:, 1:widthR, :) = 0;

<span class="comment">% set all columns from column dims(1)-r_height to dims(1) equal zero</span>
dftImg(:, dims(2)-widthR:dims(2), :) = 0;

<span class="comment">% show spectrum</span>
figure(<span class="string">'Position'</span>, [100, 100, 1440, 800], <span class="string">'name'</span>, <span class="string">'Compessed Spectrum'</span>);
imshow(normalizeMat(logPowerSpec(dftImg)))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% c)</span>

dftImg = ifftshift(dftImg);
save(<span class="string">'imgs/compressed.mat'</span>, <span class="string">'dftImg'</span>);

<span class="comment">% show file size</span>
fileInfo = dir(<span class="string">'imgs/compressed.mat'</span>);
compressedMB = fileInfo.bytes/1024^2;
disp([<span class="string">'Size Compressed File: '</span>,num2str(compressedMB), <span class="string">' MB'</span>]);
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% d)</span>

load(<span class="string">'imgs/compressed.mat'</span>, <span class="string">'dftImg'</span>);
recoveredCompressedImg = abs(ifft2(dftImg));

figure(<span class="string">'Position'</span>, [100, 100, 1440, 800], <span class="string">'name'</span>, <span class="string">'Original (left) and Compressed (right) Image'</span>)
subplot(1,2,1);
imshow(img);
title(<span class="string">'Original image'</span>);

subplot(1,2,2);
imshow(recoveredCompressedImg);
title([<span class="string">'Compressed image ('</span>, num2str(100*p), <span class="string">' percent set to 0)'</span>])

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% e)</span>

firstImgColChang = img(:,:,1);
deltaImg = (img-recoveredCompressedImg);
firstColChan = deltaImg(:,:,1);
errorL2 = (sum(firstColChan(:))^2);
errorRelL2 = errorL2 / (norm(firstImgColChang(:)));

disp(<span class="string">'Status of Compressed Image'</span>)
disp([num2str(100*p), <span class="string">' percente of the image values got replaced by 0'</span>]);
disp([<span class="string">'Compressed by a factor of '</span>, num2str((compressedMB/uncompressedMB))]);
disp([<span class="string">'L2 error: '</span>, num2str(errorL2)]);
disp([<span class="string">'Relative L2 error: '</span>, num2str(errorRelL2)]);
disp(char(10))

disp(<span class="string">'Given Compression Percentage is approx. equal to 100% - CompressionFactor*100%'</span>)
disp(<span class="string">'According to Parseval?s Theorem the spatial Energy of a signal is equal to '</span>)
disp(<span class="string">'the Energy of the signal in the frequency domain'</span>)
disp(<span class="string">'times a factor (1/M) where M is the number of samples'</span>)
disp(<span class="string">'Since use q = 1-p, where p is the user specified % compression factor'</span>)
disp(<span class="string">'and set all high freq. values in a mask of diameter srt(q*dim) to zero'</span>)
disp(<span class="string">'and our image is 2d, this corresponds to affecting this scale factor 1/M.'</span>)
disp(<span class="string">'since we reduce each dim sqrt(q)length and we have two dimensions'</span>)
disp(<span class="string">'and reducing corresponds setting the boundary with a certain width equal zero'</span>);
disp(<span class="string">'we get in the compression the ratio of length*sqrt(q)^2'</span>);
disp(<span class="string">'This is exactly equal to the compression factor mentioned above'</span>);
disp(char(10))

<span class="comment">% ===================================================== end of subtask</span>

<span class="comment">% f)</span>

experimentPRange = 0.40:0.05:0.80;
CompExpData = zeros(length(experimentPRange), 4);
idx = 1;
<span class="keyword">for</span> p=experimentPRange,

    q = 1-p;
    heightR = round((dims(1) - sqrt(q)*dims(1))/2);
    widthR = round((dims(2) - sqrt(q)*dims(2))/2);
    dftImg = fftshift(fft2(img));

    dftImg(1:heightR, :, :) = 0;
    dftImg(dims(1)-heightR:dims(1), :, :) = 0;
    dftImg(:, 1:widthR, :) = 0;
    dftImg(:, dims(2)-widthR:dims(2), :) = 0;

    dftImg = ifftshift(dftImg);

    filePathName = strcat(<span class="string">'imgs/compressed_p_'</span>,num2str(p),<span class="string">'.mat'</span>);


    save(filePathName, <span class="string">'dftImg'</span>);

    load(filePathName, <span class="string">'dftImg'</span>);
    fileInfo = dir(filePathName);
    compressedMB = fileInfo.bytes/1024^2;


    recoveredCompressedImg = abs(ifft2(dftImg));


    deltaImg = (img-recoveredCompressedImg);
    firstColChan = deltaImg(:,:,1);
    errorL2 = (sum(firstColChan(:))^2);
    errorRelL2 = errorL2 / (norm(firstImgColChang(:)));

    disp([num2str(100*p), <span class="string">' percente of the image values got replaced by 0'</span>]);
    disp([<span class="string">'Compressed by a factor of '</span>, num2str((compressedMB/uncompressedMB))]);
    disp([<span class="string">'L2 error: '</span>, num2str(errorL2)]);
    disp([<span class="string">'Relative L2 error: '</span>, num2str(errorRelL2)]);
    disp(char(10))

    CompExpData(idx, :) = [p*100, errorL2, errorRelL2, compressedMB/uncompressedMB];

    idx = idx + 1;
<span class="keyword">end</span>

disp(<span class="string">'Evaluation Compression experiment'</span>)
disp(<span class="string">'Column Format: Percentag, L2 error, rel. L2 error, compression ratio'</span>)
disp(CompExpData);
disp(char(10))
</pre><pre class="codeoutput">Parseval`s Theorem states that squared sum of the coefficients of the spatial
signal are equal to the squared sum of the signal in the frequency
domain up to a factor N.
I.e. the Energy of the spatial signal corresponds to 
the energy of the signal in the frequency scaled by a certain factor
the factor M is the number of samples taken
Since a image has n x n samples (assuming image has a quadratic resolution)
A user specified value to the square root of 2 is proportinal the length and widht
i.e. (imgLength - sqrt(1-percentage)*imgLength)) /2 
This length determines the the window of zero elements in the DFT of the image
A good strategy will be the following: Set high freqencies equal to zero
related to the computed length above.
Setting high-frequencies should work rather well since the human eye is more sensitive to low frequencies
and is not able to distinguish exactly between strength levels of a high frequency brightness variation


Size Uncompressed File: 7.6072 MB


Size Compressed File: 3.058 MB


Status of Compressed Image
60 percente of the image values got replaced by 0
Compressed by a factor of 0.40198
L2 error: 4.6981
Relative L2 error: 0.027662


Given Compression Percentage is approx. equal to 100% - CompressionFactor*100%
According to Parseval?s Theorem the spatial Energy of a signal is equal to 
the Energy of the signal in the frequency domain
times a factor (1/M) where M is the number of samples
Since use q = 1-p, where p is the user specified % compression factor
and set all high freq. values in a mask of diameter srt(q*dim) to zero
and our image is 2d, this corresponds to affecting this scale factor 1/M.
since we reduce each dim sqrt(q)length and we have two dimensions
and reducing corresponds setting the boundary with a certain width equal zero
we get in the compression the ratio of length*sqrt(q)^2
This is exactly equal to the compression factor mentioned above


40 percente of the image values got replaced by 0
Compressed by a factor of 0.60001
L2 error: 1.5343
Relative L2 error: 0.0090338


45 percente of the image values got replaced by 0
Compressed by a factor of 0.55135
L2 error: 1.9099
Relative L2 error: 0.011245


50 percente of the image values got replaced by 0
Compressed by a factor of 0.50313
L2 error: 2.7686
Relative L2 error: 0.016302


55 percente of the image values got replaced by 0
Compressed by a factor of 0.45057
L2 error: 4.0209
Relative L2 error: 0.023675


60 percente of the image values got replaced by 0
Compressed by a factor of 0.40198
L2 error: 4.6981
Relative L2 error: 0.027662


65 percente of the image values got replaced by 0
Compressed by a factor of 0.35298
L2 error: 6.0201
Relative L2 error: 0.035447


70 percente of the image values got replaced by 0
Compressed by a factor of 0.30187
L2 error: 7.3277
Relative L2 error: 0.043146


75 percente of the image values got replaced by 0
Compressed by a factor of 0.25274
L2 error: 11.8191
Relative L2 error: 0.069591


80 percente of the image values got replaced by 0
Compressed by a factor of 0.20369
L2 error: 13.7996
Relative L2 error: 0.081253


Evaluation Compression experiment
Column Format: Percentag, L2 error, rel. L2 error, compression ratio
   40.0000    1.5343    0.0090    0.6000
   45.0000    1.9099    0.0112    0.5513
   50.0000    2.7686    0.0163    0.5031
   55.0000    4.0209    0.0237    0.4506
   60.0000    4.6981    0.0277    0.4020
   65.0000    6.0201    0.0354    0.3530
   70.0000    7.3277    0.0431    0.3019
   75.0000   11.8191    0.0696    0.2527
   80.0000   13.7996    0.0813    0.2037



</pre><img vspace="5" hspace="5" src="start3_12.png" alt=""> <img vspace="5" hspace="5" src="start3_13.png" alt=""> <img vspace="5" hspace="5" src="start3_14.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
% Computational Photography Project 1
% Turned in by <Michael Single>
% Legi: 08-917-445

close all
clear all
clc

% the following variables and handles are globally available

img = imread('imgs/castle_grey.jpg');
img = im2double(img);

% test for squared error below eps 
eps = 1E-12;

% helper function: For normalizing

% log power spectrum log(1+|F|^2)
logPowerSpec = @(Mat)log(1 + Mat.*conj(Mat));

shiftMat2Min = @(Mat) Mat - min(Mat(:));
scaleMatByMax = @(Mat) Mat ./ max(Mat(:));

% map values of a given matrix to range [0,1]
normalizeMat = @(Mat) scaleMatByMax(shiftMat2Min(Mat));

transformBack = @(Mat) ifft2(ifftshift(Mat));
clipImg = @(Mat) abs(Mat(1:size(img,1), 1:size(img, 2)));

% for inverse filtering
clipTransformBack = @(Mat) clipImg(transformBack(Mat));


%% task 1

% a) plot function f(x) = cos(?ox) with ?o = 2?k/N, x ? [0, 16]
% and the sampled version f (n) frequency k = 1, . . . , 16.
% note that ?o denotes the angular frequency.
figure('Position', [100, 100, 1024, 800], 'name','Plots of cos(2pi*k*x/N) Plots');
N = 16;
idx = 1;
for k=1:16
    h = subplot(4,4,idx);
    fplot(@(x) cos((2*pi()*k/N)*x), [0, 16])
    hold on
    stem(cos((2*pi()*k/N)*(1:16)),'fill','-.');
    hold off
    title(strcat('k=',num2str(idx)))
    idx = idx + 1;
end

% ===================================================== end of subtask

% 2.b) Indicate the value of ?o and k at which f(x) hits the Nyquist frequency
disp(['N = ', num2str(N), ' thus N+1 = ', num2str(N+1), ' samples are used.']);
disp(['Hence, the sample rate f_s is equal to ', num2str(N), ' samples per time unit.']); 
disp(['Since the  Nyquist frequency f_n is equal to 0.5*f_s']); 
disp(['It follows f_n = ',num2str(N/2),' for N equal to ',num2str(N)]); 
disp(['Since k denotes a frequency we can set k = f_n = ', num2str(N/2), '(i.e. hit k hits Nyquist frequency)']);
disp(['Then omega = 2*pi*k/N = 2*pi*(N/2)/N = pi']);
disp(char(10));
% ===================================================== end of subtask


%% task 2

% f_n are the samples of the input function
% F_m are the Fourier coefficients
% Let n,m in {0...M?1}, then for a fixed M
% a) create an M ? M matrix for the DFT containing the entries of a DFT

% F_m = \sum_{n=0}^{M-1} f_n e^{ \frac{-i 2\pi m*n}{M} }
% this is equivalent to F_m = *f_n

% predefined
M = 10;

W_loop = zeros(M,M);
for m=0:M-1,
    for n=0:M-1,
        W_loop(m+1,n+1) = exp((-1i*2*pi()*m*n)/M);
    end
end

% Note that this could be further simplified:
% According to Euler's Formular exp(i*phi) = cos(phi) + i sin(phi)
% for phi (-2*pi()*m*n)/M) in this case it follows:
% cos(phi) + i sin(phi) = cos(-2*pi()*m*n)/M) + i sin(-2*pi()*m*n)/M)
% = cos(2*pi()*m*n)/M) - i sin(2*pi()*m*n)/M) % since sine is odd, cos even

% task a) without for loops 
% m,n coefficient matrix

% Indices set M as repeated row vector.
IDX = repmat((0:M-1),M, 1);

% m,n coefficient matrix
Cmn = IDX.*IDX';

% phi matrix as described above in Euler's Formula
phi = 2*pi()*Cmn/M;

% Note that we have used sin(-x) = -sin(x)
% This allows us to abstain from the '-' sign in phi's def.
W = cos(phi)-1i*sin(phi);

% sanity check is loop W equal to loopless W?
deltaW = (W - W_loop);
if(abs(sum(deltaW(:))) < 1E-12)
    disp('W is okay')
else 
    disp('Error: W does not correspond to its loop version!')
end
disp(char(10))
% ===================================================== end of subtask

% b) check det(U), U*U' = eye(M) = U'*U
disp('Let U := W/sqrt(M)')
U = (W / sqrt(M));

% due to numerical precisson we have to check 
% whether |U*U' - I| < eps |U'*U - I| < eps |det(U) - 1| < eps

% condition |det(U)| = 1
cond1 = (abs(det(U))-1)^2 < eps;

% conditions U*U = UU* = I.
cond2 = (sum(sum(U*U'-eye(M))))^2 < eps;
cond3 = (sum(sum(U'*U-eye(M))))^2 < eps;

% in matlab comparison yielding true corresponds to be equal 1.
% since we have three conditions to check, all are true if their sum is 3.
if( cond1 + cond2 + cond3 == 3 )
    disp('|det(U)| = 1 and U*U = UU* = I holds true');
else
    disp('Error: At least one condition, |det(U)| = 1 and U*U = UU* = I, does not true');
end
disp(char(10))

% ===================================================== end of subtask

% c)
% Plot elements in DFT matrix
figure('Position', [100, 100, 1024, 800], 'name', 'real and imag DFT coefficent W plots');

% A the k-th row in M corresponds to coefficients 
% necessary in order to calculate F_k: F_k = M(k,;)*f_n
% Plot rows in W, i.e. coefficients F_k wise.
for m=0:M-1
    subplot(M,2,2*(m+1)-1);
    plot(0:M-1, real(W(m+1,:)), 'r', 0:M-1, imag(W(m+1,:)), 'b');
    if(m==0)
        title('Rows in DFT matrix, real (red) and imaginary (blue) (i-th figure are coeff of Fi)');
    end
end

% Plotting varying (sin, cos)(kx) for varying freq. values k. in range [0,M-1]
for k=0:M-1
    subplot(M,2,2*(k+1));
    fplot(@(x)sin(k*x), [0,M-1], 'r');
    hold on;
    fplot(@(x)cos(k*x), [0,M-1], 'b');
    if(k==0)
        title('sin (red) and cos (blue) for varying frequency values k (i-th figure is k=i)');
    end
end
disp('My Observations:');
disp('Elements in W are equal to e^(-i*2*pi*k/M) = cos(-2*pi*k/M) + i*sin(-2*pi*k/M) (Euler Fromula)'); 
disp('real(e^(-i*2*pi*k/M)) = cos(2*pi*k) (cos is even function');
disp('imag(e^(-i*2*pi*k/M)) = -sin(2*pi*k/M) (sin is odd function');
disp('Until Index M/2 + 1 (assuming M is even) the follwoing holds true:');
disp('See first M/2 + 1 rows in first column in subfigure plots');
disp('Therefore plotting real(e^(-i*2*pi*k/M) gives us a cosine wave with period k');
disp('and plotting imag(e^(-i*2*pi*k/M) gives us a sine wave with period k');
disp('Index m=M/2 has imag = 0');
disp('The periods descrease symmetrically like they increased from this index on.');
disp('In addition, since the real part is a cos wave which is an even function');
disp('the plot of the k-th index is the same as (M/2 - k + 1)-th index (assuming M is even)');
disp('Similarly, the can reason for sine, but it is flipped since sine is an even function');
disp('i.e. sine at k-th plot corresponds to same plot times -1 of (M/2 - k + 1)-th');
disp('To make this observation clear');
disp('Set M=10 in this task and we assume that the first figure is labeled by index 1');
disp('Comparing 3rd figure in column 1 with the 9th figure in column 1, we see that ');
disp('their red curves are the same and that the blue curve of the 3rd one is -1 times the 9th one');
disp('furthermore both have a period equal to 2');
disp(char(10))

% ===================================================== end of subtask

%d)
% Take M samples at 2n?/M, n = 0,...,M ?1 of cos(kx) and store them in a vector x.
x = (2*pi()*(0:M-1));
for k=0:M-1,
    disp(['For k=',num2str(k), ':']);
    Fk = W*cos(x)';
    matlabFk = fft(cos(k * x))';
    
    % W*f_m is equal to FFT{f_m}
    % squered error below eps
    dftsAreTheSame = sum(Fk-matlabFk)^2 < eps;
    if(dftsAreTheSame == 1)
        disp('W*f_k is the same as Matlab`s FFT{f_k}')
    else
        display('Eror: W*f_k NOT SAME as Matlab`s FFT{f_k}')
    end
    
    shiftedFk = fftshift(Fk);
    shiftedMatlabFk = fftshift(matlabFk);
    
    shiftedDftsAreTheSame = (sum(shiftedFk-shiftedMatlabFk)^2 < eps);
    if(shiftedDftsAreTheSame == 1)
        disp('shifted W*f_k is the same as Matlab`s shifted FFT{f_k}')
    else
        display('Eror: shifted W*f_k NOT SAME as shifted Matlab`s FFT{f_k}')
    end
    disp(char(10));
end

disp('My Intuition:');
disp('from Matlab`s help page about the fftshift function:');
disp('1. shifts the zero-frequency component to center of spectrum');
disp('I.e. For a vector v, fftshift(v) swaps the left and right halves of v');
disp(char(10));
disp('Fact: The dft of a function is a Periodic Function');
disp('In our case we the dft of the function is a vector v with M elements.');
disp('Appending the 2nd half of this vector to the first half');
disp('which correspond to swapping the left and right halves of v');
disp('this gives us a center symmetric vector looking like this');
disp('[4,3,2,1,2,3] where `1` is the centered zero frequency.');
disp('Before shifting: [1,2,3,4,3,2] we had this periodic function (aft dft)');
disp(char(10));

% In addition the following example
% a random column vector with 9 elements.
%{
randV = 
    0.9857
    0.1528
    0.7248
    0.9652
    0.3301
    0.5656
    0.0009
    0.8532
    0.5268

% its dft transformation
fft(randV) =
   5.1052 + 0.0000i
   0.4556 + 0.3877i
  -0.1761 - 1.0960i
   0.3752 - 0.4166i
   1.2283 + 1.0215i
   1.2283 - 1.0215i
   0.3752 + 0.4166i
  -0.1761 + 1.0960i
   0.4556 - 0.3877i

% its shifted dft transformation:
 fftshift(fft(randV)) =
   1.2283 - 1.0215i
   0.3752 + 0.4166i
  -0.1761 + 1.0960i
   0.4556 - 0.3877i
   5.1052 + 0.0000i
   0.4556 + 0.3877i
  -0.1761 - 1.0960i
   0.3752 - 0.4166i
   1.2283 + 1.0215i
%}

% ===================================================== end of subtask

% e)
disp('For 1D Fourier tranformation when given M elements');
disp('The DFT has an asymptotic complexity of O(M^2)');
disp('The FTT has an asymptotic complexity of O(M*log(M)');
disp('Speedup factor using the FFT algorithm instead computing DFT Matrix:'); 
disp('O([M^2] / [M*log(M)]) which is in O(M/log(M))');
disp('E.g. given an nxn image (monochromatic) => i.e. M = n^2 (serialized image');
disp('using the DFT algorithm has a asym. complexity in O([n^4]');
disp('using the FFT algorithm has a asym. complexity in O([n^2 log(n^2)]');
disp('which is equal to O([2*(n^2) log(n)] = O([(n^2)*log(n)]');
disp('Assuming for the derivation of the FFT algorithm was a regular Divide&Conquer approach applied')
disp('we referre to the logarithm to the basis of 2, when talking about log')
disp('Therefore, if n=400, then');
disp('using the DFT algorithm: about 2.5600e+10 Iterations');
disp('using the FFT algorithm: about 1.3830e+06 Iterations');
disp('This is for this case a speedup about 4 orders of magnitude (1.8510e+04)');
disp(char(10));

% ===================================================== end of subtask


%% task 3

% a) compute 2dim Fourier transform of a grayscale image
img = imread('imgs/castle_grey.jpg');
img = im2double(img);
imgDft2 = fft2(img);

% ===================================================== end of subtask

% b) 
oneChannel = img(:,:,1);
centerFreqSameAsPixelsum = (imgDft2(1,1)-sum(oneChannel(:)))^2 < eps;
if(centerFreqSameAsPixelsum == 1)
    disp('Element (1,1) of the Fourier transform corresponds to the sum over all pixel values.');
else
    disp('Error: Pixel value sum not central frequency (1,1)')
end
disp(char(10));

% ===================================================== end of subtask

% c) Verify Perseval's Theorem.
M = size(img,1)*size(img,2);
persevalsTheoremHoldsTrue = sum(sum(sum(img.^2))...
                                -(1/M)*sum(sum(imgDft2.*conj(imgDft2)))).^2 < eps;
if(sum(persevalsTheoremHoldsTrue) == 1)
    disp('Perseval`s Theorem holds true');
else
    disp('Error: Perseval`s Theorem does NOT hold true')
end
disp(char(10));                    

% ===================================================== end of subtask

% d) Center dft2 of image
centeredDFT = fftshift(imgDft2);

% ===================================================== end of subtask

% e) Visualize power spectrum

% power spectrum S = |F|^2
S = centeredDFT .* conj(centeredDFT);

% logarithmic values in order to reduce the contrast
spectrum = log(1+S);
% normalize spectrum linearly into range [0,1]
spectrum = (spectrum - min(spectrum(:)));
spectrum = spectrum ./ max(spectrum(:));
figure('name', 'Centered and Scaled Power Spectrum of Image');
imshow(spectrum);

% ===================================================== end of subtask

% f) Visualize phase angles

dftPhase = angle(centeredDFT);
dftPhase = dftPhase - min(dftPhase(:));
dftPhase = dftPhase ./ max(dftPhase(:));
figure('name', 'Centered and Scaled phase angles of Image');
imshow(dftPhase);

% ===================================================== end of subtask


%% task 4

% a) 

% Since filtering in the Fourier domain corresponds to circular convolution
% need to zero-pad the image to avoid boundary artifacts
% zero-pad using twice the size of the image itself
dims = size(img);

% apply dft with zero padding
imgDft2 = fft2(img, 2*dims(1), 2*dims(2));

% ===================================================== end of subtask

% b) 

% basic dimensions:
[height, width, ~] = size(imgDft2);
h = (height - 1)/2;
w = (width - 1)/2;
% Normalized Distances
[x,y] = meshgrid(-w:w,-h:h);
D = x.^2 + y.^2;
D = D-min(D(:));
D = D ./ max(D(:));

% Construct Buttworth Highpass filter: highpass = 1 - lowpass 
% assuming (normalization): Is a function of (D0, n).
H_lowpass = @(D0,n) 1./((1+(D/D0)).^(2*n));
H_highpass = @(D0,n) 1 - H_lowpass(D0,n);

% constr

% Define band pass filter: as a function of (W,D0,n)
H_bandass = @(W,D0,n) 1-(1 ./ (1 + ((W.*D)./(D.^2 - D0^2)).^(2*n)));

% ===================================================== end of subtask

% c)
ns = [2, 10]; % n value used in the slides.
D0s = [0.1, 0.2, 0.3];
Ws = [0.05, 0.1, 0.2];

% Superfancy-modular filter-visualization loop 
figure('Position', [100, 100, 1024, 800], 'name','Visualize log Power Spectrum of filters');

figIdx = 1;
for nIdx=1:length(ns),
    for D0Idx=1:length(D0s),
        
        D0 = D0s(D0Idx);
        n = ns(nIdx);
        
        % current lowpass filter
        fig_title = strcat('LowP: D0='...
                            ,num2str(D0), ' n=', num2str(n));       
        normLow = normalizeMat(logPowerSpec(H_lowpass(D0, n)));
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normLow);
        xlabelHandler = get(g,'XLabel');
        set( xlabelHandler, 'String', fig_title); 
        set(gca,'xtick',[],'ytick',[]);
        figIdx = figIdx + 1;
        
        
        % current highpass filter
        fig_title = strcat('HiP: D0='...
                            ,num2str(D0), ' n=', num2str(n));                        
        normHigh = normalizeMat(logPowerSpec(H_highpass(D0, n)));
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normHigh);
        xlabelHandler = get(g,'XLabel');
        set( xlabelHandler, 'String', fig_title);
        set(gca,'xtick',[],'ytick',[]);
        figIdx = figIdx + 1;
        
        % only for bandpass filter
        for WIdx=1:length(Ws),
            W = Ws(WIdx);
            fig_title = strcat('BandP: D0='...
                            ,num2str(D0), ' n=', num2str(n), ' W',num2str(W));       
            normBand = normalizeMat(logPowerSpec(H_bandass(W,D0,n)));
            g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
            subimage(normBand);
            xlabelHandler = get(g,'XLabel');
            set( xlabelHandler, 'String', fig_title);
            set(gca,'xtick',[],'ytick',[]);
            figIdx = figIdx + 1;
        end
    end
end

% some legend related information
disp('Note that in the previous figure all a row corresponds to a certain D0');
disp('The 1st column is the lowpass filter spectrums');
disp('The 2nd column is the highpass filter spectrum');
disp('And the columns 3-5 are the bandpass filter spectrums for varying W');
disp(char(10));
disp(char(10));

disp('My observations:')
disp('The filters in the previous figure are normalized - range from [0,1]')
disp('Therefore, the brighter the higher the weighting value and vice versa')
disp('White corresponds to the weight 1, black to the weight 0');
disp('Low Pass filter: weighting frequencies closer the center more than those further away');
disp('Select the lower frequencies:') 
disp('Filters hight frequencies out (the detail). Thus we get Blurs image');
disp(char(10));
disp('High Pass filter: weights frequencies further away from the center more than those closer to the center');
disp('Filters low frequencies out.')
disp('The closer this filter gets towards zero, the closer its filtered result is to the original input image');
disp(char(10));
disp('the bandpass filter is a disk selecting a certain band spectrum')
disp(char(10));
disp('D0 affects the size of the radius:');
disp('The bigger D0 the bigger the radius gets and vice versa.');
disp('W affects the width of the filter band:');
disp('Increasing W increases the filter band width.');
disp('Loosly speaking it affects the inner radius of the disk');
disp('the bigger W gets, the smaller the inner radius gets');
disp('N Determins the smoothness of the circle border:');
disp('The higher n gets the sharper the transition');
disp('I.e. low value of n => smooth');
disp('I.e. very high value of n => sharp');


% ===================================================== end of subtask

% d)
imgDft2 = imgDft2(:,:,1);
imgDft2 = fftshift(imgDft2);

% showing power spectrum of images.
figure('Position', [100, 100, 1024, 800], 'name','Spectrum of filtered DFT Img');
figIdx = 1;
for nIdx=1:length(ns),
    for D0Idx=1:length(D0s),
        
        D0 = D0s(D0Idx);
        n = ns(nIdx);
        
        % current lowpass filter
        fig_title = strcat('LowP: D0='...
                            ,num2str(D0), ' n=', num2str(n));       
        normLow = normalizeMat(logPowerSpec(imgDft2 .* H_lowpass(D0, n)));
        
        
        
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normLow);
        xlabelHandler = get(g,'XLabel');
        set( xlabelHandler, 'String', fig_title); 
        set(gca,'xtick',[],'ytick',[]);
        figIdx = figIdx + 1;
        
        
        % current highpass filter
        fig_title = strcat('HiP: D0='...
                            ,num2str(D0), ' n=', num2str(n));                        
        normHigh = normalizeMat(logPowerSpec(imgDft2.*H_highpass(D0, n)));
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(normHigh);
        xlabelHandler = get(g,'XLabel');
        set( xlabelHandler, 'String', fig_title);
        set(gca,'xtick',[],'ytick',[]);
        figIdx = figIdx + 1;
        
        % only for bandpass filter
        for WIdx=1:length(Ws),
            W = Ws(WIdx);
            fig_title = strcat('BandP: D0='...
                            ,num2str(D0), ' n=', num2str(n), ' W',num2str(W));       
            normBand = normalizeMat(logPowerSpec(imgDft2.*H_bandass(W,D0,n)));
            g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
            subimage(normBand);
            xlabelHandler = get(g,'XLabel');
            set( xlabelHandler, 'String', fig_title);
            set(gca,'xtick',[],'ytick',[]);
            figIdx = figIdx + 1;
        end
    end
end

% recovering images using the filters
figure('Position', [100, 100, 1024, 800], 'name','Filter Imges');
figIdx = 1;
for nIdx=1:length(ns),
    for D0Idx=1:length(D0s),
        
        D0 = D0s(D0Idx);
        n = ns(nIdx);
        
        % current lowpass filter
        fig_title = strcat('LowP: D0='...
                            ,num2str(D0), ' n=', num2str(n));       
        normLow = imgDft2 .* H_lowpass(D0, n);
        
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(clipTransformBack(normLow));
        xlabelHandler = get(g,'XLabel');
        set( xlabelHandler, 'String', fig_title); 
        set(gca,'xtick',[],'ytick',[]);
        figIdx = figIdx + 1;
        
        
        % current highpass filter
        fig_title = strcat('HiP: D0='...
                            ,num2str(D0), ' n=', num2str(n));                        
        normHigh = imgDft2.*H_highpass(D0, n);
        g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
        subimage(clipTransformBack(normHigh));
        xlabelHandler = get(g,'XLabel');
        set( xlabelHandler, 'String', fig_title);
        set(gca,'xtick',[],'ytick',[]);
        figIdx = figIdx + 1;
        
        % only for bandpass filter
        for WIdx=1:length(Ws),
            W = Ws(WIdx);
            fig_title = strcat('BandP: D0='...
                            ,num2str(D0), ' n=', num2str(n), ' W',num2str(W));       
            normBand = imgDft2.*H_bandass(W,D0,n);
            g = subplot(length(ns)*length(D0s),2+length(Ws),figIdx);
            subimage(clipTransformBack(normBand));
            xlabelHandler = get(g,'XLabel');
            set( xlabelHandler, 'String', fig_title);
            set(gca,'xtick',[],'ytick',[]);
            figIdx = figIdx + 1;
        end
    end
end

% ===================================================== end of subtask


%% task 5

% a)
% gaussian 5x5 kernel with sigma=3
gaussianFilter = fspecial('gaussian',5,1);
blurredImg = imfilter(img, gaussianFilter);

% ===================================================== end of subtask

% b) 

noisyBluredImg = imnoise(blurredImg, 'gaussian', 0, 0.05);

% c)
% centered zero-padded-dft of noisy and noisy-blured imgs
dftBluredImg = fftshift(fft2(blurredImg, 2*dims(1), 2*dims(2)));
dftBluredImg = dftBluredImg(:,:,1);
dftNoisyBluredImg = fftshift(fft2(noisyBluredImg, 2*dims(1), 2*dims(2)));
dftNoisyBluredImg = dftNoisyBluredImg(:,:,1);
dftGaussian = fftshift(fft2(gaussianFilter, 2*dims(1), 2*dims(2)));

% Inverse filtering
invFilteredBlurred = dftBluredImg ./ dftGaussian;
invFilteredNoisyBlured = dftNoisyBluredImg ./ dftGaussian;

figure('name', 'Recovered blury image by Inverse Filtering')
imshow(clipTransformBack(invFilteredBlurred))

figure('name', 'Recovered Noisy image by Inverse Filtering')
imshow(clipTransformBack(invFilteredNoisyBlured))

figure('name', 'Recovered Noisy image by Inverse Filtering scaled linearly to [0,1] range')
imshow(normalizeMat(clipTransformBack(invFilteredNoisyBlured)))


disp('Let I be a given image');
disp('H denotes a filter (here a gaussian filter)');
disp('and N denote noise');
disp('Assuming the Degradation Model')
disp('Then G = H*I + N is the noisy image')
disp('Applying inverse filtering to G using H gives us then:')
disp('invI = G/H = I + N/H');
disp('If the elements in H are relatively small')
disp('the ratio N/H will be relatively large')
disp('Thus, assuming - which is the case in our example -')
disp('that the values the elements in H (our gaussian Filter) are very small')
disp('The noisy will then dominate in the recovered image invI')
disp('This can be observed in the figures shown previousely.')
disp('Note that scale the image linearly into the range [0,1] does not help')
disp('This can also be oberved in one of the previous figures.')
disp('In contrary, images without exhibiting any significant noise')
disp('can be rather well recovered relying on the inverse method')
disp(char(10))

% ===================================================== end of subtask

% d)

figure('Position', [100, 100, 1440, 800], 'name', 'Recovered Noisy Image a using Wiener Filter');
SNR = 0:0.1:0.8;
for idx = 1:length(SNR),
    recoveredImg = deconvwnr(noisyBluredImg, gaussianFilter, SNR(idx));
    subplot(3,3,idx);
    imshow(recoveredImg);
    title(['Recovered image using a Wiener Filter with SNR = ', num2str(SNR(idx))]);
end

disp('The following reasoning does hold true for Wiener filters:');
disp('SNR denotes signal to noise ratio, i.e. Sf(u;v) / Sn(u;v)');
disp('IF the SNR is equal to zero then either');
disp('a) Sf(u;v) is zero for all u,v i.e. there is no signal OR');
disp('b) Sn(u;v) is extremly large for all u,v (almost infinity noise)');
disp('Since case a) clearly cannot be true (since we do have a signal)');
disp('i.e. an image != black');
disp('Case be must be true');
disp('Thus, case b) corresponds to the case when we have almost infinite noise (contribution)');
disp('This can be observed in the first subfigure in the previous figure.');
disp('Having almost inf. Noise will make the Wiener Filter formular almost equal zero');
disp('and then only noise will then dominate.');
disp(char(10))

% ===================================================== end of subtask

%% task 6

% a)
disp('Parseval`s Theorem states that squared sum of the coefficients of the spatial') 
disp('signal are equal to the squared sum of the signal in the frequency') 
disp('domain up to a factor N.');
disp('I.e. the Energy of the spatial signal corresponds to ')
disp('the energy of the signal in the frequency scaled by a certain factor');
disp('the factor M is the number of samples taken')
disp('Since a image has n x n samples (assuming image has a quadratic resolution)')
disp('A user specified value to the square root of 2 is proportinal the length and widht')
disp('i.e. (imgLength - sqrt(1-percentage)*imgLength)) /2 ')
disp('This length determines the the window of zero elements in the DFT of the image')
disp('A good strategy will be the following: Set high freqencies equal to zero')
disp('related to the computed length above.');
disp('Setting high-frequencies should work rather well since the human eye is more sensitive to low frequencies');
disp('and is not able to distinguish exactly between strength levels of a high frequency brightness variation');
disp(char(10))

% ===================================================== end of subtask

% b)

% user specified percentage value
p = 0.6;
q = 1-p;

heightR = round((dims(1) - sqrt(q)*dims(1))/2);
widthR = round((dims(2) - sqrt(q)*dims(2))/2);

% dft is centered i.e. low freq. closer to center
dftImg = fft2(img);
save('imgs/uncompressed.mat', 'dftImg');

% show file size
fileInfo = dir('imgs/uncompressed.mat');
uncompressedMB = fileInfo.bytes/1024^2;
disp(['Size Uncompressed File: ',num2str(uncompressedMB), ' MB']);
disp(char(10))

dftImg = fftshift(dftImg);

figure('Position', [100, 100, 1440, 800], 'name', 'Uncompressed Spectrum');
imshow(normalizeMat(logPowerSpec(dftImg)))

% Replace high frequencies with 0 
% zero-mask frequencies with a top-down-left-right-box having some
% width-height.
%{ 
E.g.

a a a a a a a a      0 0 0 0 0 0 0 0
a a a a a a a a      0 0 0 0 0 0 0 0
a a a a a a a a      0 0 a a a a 0 0
a a a a a a a a  =>  0 0 a a a a 0 0
a a a a a a a a      0 0 a a a a 0 0
a a a a a a a a      0 0 0 0 0 0 0 0
a a a a a a a a      0 0 0 0 0 0 0 0

%}
% set all rows from row 1 to row heightR equal zero
dftImg(1:heightR, :, :) = 0;

% set all rows from row dims(1)-r_height to dims(1) equal zero
dftImg(dims(1)-heightR:dims(1), :, :) = 0;

% set all columns from column 1 to row heightR equal zero
dftImg(:, 1:widthR, :) = 0;

% set all columns from column dims(1)-r_height to dims(1) equal zero
dftImg(:, dims(2)-widthR:dims(2), :) = 0;

% show spectrum
figure('Position', [100, 100, 1440, 800], 'name', 'Compessed Spectrum');
imshow(normalizeMat(logPowerSpec(dftImg)))

% ===================================================== end of subtask

% c)

dftImg = ifftshift(dftImg);
save('imgs/compressed.mat', 'dftImg');

% show file size
fileInfo = dir('imgs/compressed.mat');
compressedMB = fileInfo.bytes/1024^2;
disp(['Size Compressed File: ',num2str(compressedMB), ' MB']);
disp(char(10))

% ===================================================== end of subtask

% d)

load('imgs/compressed.mat', 'dftImg');
recoveredCompressedImg = abs(ifft2(dftImg));

figure('Position', [100, 100, 1440, 800], 'name', 'Original (left) and Compressed (right) Image')
subplot(1,2,1);
imshow(img);
title('Original image');

subplot(1,2,2);
imshow(recoveredCompressedImg);
title(['Compressed image (', num2str(100*p), ' percent set to 0)'])

% ===================================================== end of subtask

% e)

firstImgColChang = img(:,:,1);
deltaImg = (img-recoveredCompressedImg);
firstColChan = deltaImg(:,:,1);
errorL2 = (sum(firstColChan(:))^2);
errorRelL2 = errorL2 / (norm(firstImgColChang(:)));

disp('Status of Compressed Image')
disp([num2str(100*p), ' percente of the image values got replaced by 0']);
disp(['Compressed by a factor of ', num2str((compressedMB/uncompressedMB))]);
disp(['L2 error: ', num2str(errorL2)]);
disp(['Relative L2 error: ', num2str(errorRelL2)]);
disp(char(10))

disp('Given Compression Percentage is approx. equal to 100% - CompressionFactor*100%')
disp('According to Parseval?s Theorem the spatial Energy of a signal is equal to ')
disp('the Energy of the signal in the frequency domain')
disp('times a factor (1/M) where M is the number of samples')
disp('Since use q = 1-p, where p is the user specified % compression factor')
disp('and set all high freq. values in a mask of diameter srt(q*dim) to zero')
disp('and our image is 2d, this corresponds to affecting this scale factor 1/M.')
disp('since we reduce each dim sqrt(q)length and we have two dimensions')
disp('and reducing corresponds setting the boundary with a certain width equal zero');
disp('we get in the compression the ratio of length*sqrt(q)^2');
disp('This is exactly equal to the compression factor mentioned above');
disp(char(10))

% ===================================================== end of subtask

% f)

experimentPRange = 0.40:0.05:0.80;
CompExpData = zeros(length(experimentPRange), 4);
idx = 1;
for p=experimentPRange,
    
    q = 1-p;
    heightR = round((dims(1) - sqrt(q)*dims(1))/2);
    widthR = round((dims(2) - sqrt(q)*dims(2))/2);
    dftImg = fftshift(fft2(img));
      
    dftImg(1:heightR, :, :) = 0;
    dftImg(dims(1)-heightR:dims(1), :, :) = 0;
    dftImg(:, 1:widthR, :) = 0;
    dftImg(:, dims(2)-widthR:dims(2), :) = 0;
    
    dftImg = ifftshift(dftImg);
    
    filePathName = strcat('imgs/compressed_p_',num2str(p),'.mat');
    
    
    save(filePathName, 'dftImg');
    
    load(filePathName, 'dftImg');
    fileInfo = dir(filePathName);
    compressedMB = fileInfo.bytes/1024^2;
    
    
    recoveredCompressedImg = abs(ifft2(dftImg));
    
    
    deltaImg = (img-recoveredCompressedImg);
    firstColChan = deltaImg(:,:,1);
    errorL2 = (sum(firstColChan(:))^2);
    errorRelL2 = errorL2 / (norm(firstImgColChang(:)));
    
    disp([num2str(100*p), ' percente of the image values got replaced by 0']);
    disp(['Compressed by a factor of ', num2str((compressedMB/uncompressedMB))]);
    disp(['L2 error: ', num2str(errorL2)]);
    disp(['Relative L2 error: ', num2str(errorRelL2)]);
    disp(char(10))
    
    CompExpData(idx, :) = [p*100, errorL2, errorRelL2, compressedMB/uncompressedMB];
    
    idx = idx + 1;
end

disp('Evaluation Compression experiment')
disp('Column Format: Percentag, L2 error, rel. L2 error, compression ratio')
disp(CompExpData);
disp(char(10))


##### SOURCE END #####
--></body></html>